## 課題1
### エンティティ
一意の識別子で同一判定されるモデルであり、時間と共に状態が変更される可能性がある。

### 値オブジェクト（バリューオブジェクト）
属性の組み合わせによって識別されるモデルであり、属性の値がすべて同じであれば同一とみなす。
また、常に不変である。
必ず集約ルートがエンティティになるので、属することが考えられる。

### 集約
ドメインモデルをまとめて1つの単位として扱うパターンである。
必ず集約ルートと呼ばれるエンティティが存在し、集約内の他のエンティティや値オブジェクトとの関係を管理し、集約全体の整合性を保つ。集約同士が独立していると、整合性が保たれた状態で変更や操作ができ、システムの複雑さを軽減し、保守性の向上につながる。整合性を保つという意味で、集約をトランザクションの単位として扱うことも可能である。

### ユビキタス言語
プロジェクトに関わるすべての人が共通で使用する言語のことである。

### 境界づけられたコンテキスト
ドメインモデルを特定の範囲や境界内に制限し、その範囲内でのみ有効なモデルを定義することである。システム全体を複数の独立したコンテキストに分割し、それぞれのコンテキスト内で一貫性のあるモデルを保つことができる。
コンテキスト間の依存関係が最小限になり、柔軟性や拡張性が向上する。

例) 注文システム
- 注文管理コンテキスト
- 在庫管理コンテキスト
- 支払い処理コンテキスト

### ドメイン
ビジネスに関する領域や業務に関連する知識、概念、プロセス、ルールなどを表す言葉である。

### ドメインサービス
エンティティや値オブジェクトだけでは表現できないドメインの操作やビジネスロジックを実現するための概念である。状態は持たないことの方が多い。

### リポジトリ
ドメインオブジェクトの永続化や復元を担当する。
アプリケーションの柔軟性、テスト容易性、再利用性、およびコードの結合度の低減につながる。

### アプリケーション
ドメイン層（ビジネスロジックやドメインオブジェクトが含まれる）とインフラストラクチャ層（データストアや外部サービスへのアクセスが含まれる）の間に位置する層である。具体的なユースケースを表現するアプリケーションサービスを実装する。インフラ層に対して、外部サービスと連携することも可能である。

### CQS,CQRS
どちらもオブジェクトやシステムの操作を分離・整理することを目的とするアーキテクチャパターンである。

CQS(Command Query Separation)
オブジェクト状態を更新する操作をコマンド、オブジェクトの状態を問い合わせる操作をクエリとして分離する。オブジェクトレベルの原則に留まる。

CQRS(Command Query Responsibility Segregation)
コマンドとクエリの責任をさらに分離し、それぞれ別のオブジェクトやサブシステムで処理するアーキテクチャパターンである。システムレベルのアーキテクチャパターンで、コマンドとクエリの責任を別のオブジェクトやサブシステムで処理する。

どちらも結合度が低くなるため、保守性、再利用性、拡張性が向上する。

### DTO
DTO(Data Transfer Object)は異なる層やオブジェクトでデータを転送するために使用されるオブジェクトである。
例えば、APIのレスポンスデータをアプリケーション層に渡す場合などに利用される。
層間の依存関係を減り、データの整合性を保つことができる。(コード規約などに縛られなくなる？)

### ドメインモデル貧血症
ドメインモデルが主にデータ構造（プロパティやフィールド）だけを持ち、ビジネスロジックや振る舞いがほとんど含まれない状態である。ビジネスロジックが他の層で実現されていることが予想される。回避するためにはドメインモデルの定義が適切かどうかを定期的に議論する必要がある。

## 課題2

### 2-1
オンライン銀行システム

口座管理のコンテキストにおけるお金は、口座の残高や利子に関連するドメインモデルやルールに焦点を当てることが想定される。
その一方で、送金処理というコンテキストにおけるお金は、資金移動や送金手数料、通貨変換に関連するドメインモデルやルールに焦点を当てることが想定される。

### 2-2

[ユースケース](https://github.com/Hikaru-Giannis/PrAha_Challenge/tree/main/ddd/UseCase)

[エンティティ](https://github.com/Hikaru-Giannis/PrAha_Challenge/tree/main/ddd/Entity)

[値オブジェクト](https://github.com/Hikaru-Giannis/PrAha_Challenge/tree/main/ddd/ValueObject)

- TypeScriptにおいては、ValueObjectの値を参照する場合は、ゲッターではなく、public readonlyでも問題なさそう？
- TypeScriptでは、コンストラクタの型定義でリテラル型を使った方が良いのか。または両方するべきか。

## 課題3
ドメインロジックが漏れているコード (投稿システムを想定)

[Bad Code](./bad_sample.ts)

### 問題点
プロパティが`public`になっているため、どこからでも参照することができる。そのため、どこでもプロパティの値を参照して自由なロジックを記述することができてしまう。

① 判定条件がわかりづらいコードを生み出す

コードだけだとなんの判定をしているか、わからない
````typescript
if (!user1.isPremium && user1.posts.length >= 5) {
  ...
}
````

② ロジックが重複する可能性がある。

③ 機能改修などする際にプロパティを変更するだけで影響範囲が広がるため、保守性が低下する。

### 改善
- privateプロパティで専用メソッドを設ける。
- ドメインサービスや仕様オブジェクトの利用を検討する。

[Good Code](./good_sample.ts)

### 課題4
解答に自信がないです...。他の方の意見をお聞きしてみたいです。

- ドメインイベントについて、説明してください。
<details>
<summary>解答</summary>
システム内で特定の状態変化が発生したときに生成され、それをパブリッシャが出版 (publish) し，サブスクライバがドメインイベントを購読 (subscribe) して何らかの処理を行う。
</details>

- ユーザー新規登録後に登録完了メールを送信する場合は、DDDではどのように実装することが想像されますか。
<details>

<summary>解答</summary>
個人的解答
<br>
① ドメインイベントに`UserRegistered`を定義
② ドメイン層にUserRegisteredEmailクラスを定義
③ ドメイン層にEmailSenderインタフェースを定義
④ インフラ層にEmailSenderの実装クラス
</details>


